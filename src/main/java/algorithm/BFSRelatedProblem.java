package algorithm;

/**
 * BFS相关问题
 */
public class BFSRelatedProblem {


    /**
     * 1.最短单词路径
     *
     * 题目：给定两个单词（beginWord和endWord）和一个字典，找到从beginWord到endWord的最短转换序列的长度。转换需遵循如下规则：
     * 每次转换只能改变一个字母。
     * 转换过程中的中间单词必须是字典中的单词。
     *
     * 说明:
     * 如果不存在这样的转换序列，返回 0。
     * 所有单词具有相同的长度。
     * 所有单词只由小写字母组成。
     * 字典中不存在重复的单词。
     * 你可以假设beginWord和endWord是非空的，且二者不相同。
     */


    /**
     * 2.完全平方数
     * <p>
     * 题目：给定正整数n 找到若干个完全平方数（比如 1，4，9，16...）使得他们的和等于n
     * 需要让组成和的完全平方数的个数最少。
     * <p>
     * 思路：可以将每个整数看成图中的一个节点 如果两个整数之差为一个平方数 那么这两个整数所在的节点就有一条边
     * 要求解最小的平方数数量 就是求解从节点n到节点0的最短路径
     */
    public static int minCostSquares(int n) {

        return 0;
    }


    /**
     * 3.计算在网格中从原点到特定点的最短路径长度
     */
}
