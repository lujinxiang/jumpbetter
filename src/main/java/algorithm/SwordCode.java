package algorithm;

import common.Node;
import common.TreeNode;
import leetcode.problem.ListNode;

import java.util.List;

/**
 * 剑指offer训练
 *
 * @Author jinxianglu
 */
public class SwordCode {


    /**
     * 1.数组中重复的数字
     *
     * @param nums
     * @return
     */
    public int findRepeatNumber(int[] nums) {


        return 0;
    }


    /**
     * 2.二维数组中的查找
     *
     * @param matrix
     * @param target
     * @return
     */
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        return false;

    }

    /**
     * 3.替换空格
     *
     * @param s
     * @return
     */
    public String replaceSpace(String s) {
        return null;

    }


    /**
     * 4.从尾到头打印链表
     *
     * @param head
     * @return
     */
    public int[] reversePrint(ListNode head) {

        return null;

    }

    /**
     * 5.重建二叉树
     *
     * @param preorder
     * @param inorder
     * @return
     */
    public TreeNode buildTree(int[] preorder, int[] inorder) {


        return null;

    }


    /**
     * 6.用两个栈实现队列
     */
    static class CQueue {

        public CQueue() {

        }

        public void appendTail(int value) {

        }

        public int deleteHead() {
            return 0;
        }
    }


    /**
     * 7.斐波那契数列
     *
     * @param n
     * @return
     */
    public int fib(int n) {
        return 0;
    }


    /**
     * 8.青蛙跳台阶
     *
     * @param n
     * @return
     */
    public int numWays(int n) {

        return 0;
    }

    /**
     * 9.旋转数组的最小数字
     *
     * @param numbers
     * @return
     */
    public int minArray(int[] numbers) {
        return 0;
    }


    /**
     * 10.矩阵中的路径
     *
     * @param board
     * @param word
     * @return
     */
    public boolean exist(char[][] board, String word) {
        return false;
    }


    /**
     * 11.剪绳子
     *
     * @param n
     * @return
     */
    public int cuttingRope(int n) {
        return 0;

    }

    /**
     * 12.剪绳子II
     *
     * @param n
     * @return
     */
    public int cuttingRope2(int n) {
        return 0;

    }

    /**
     * 13.二进制中1的个数
     *
     * @param n
     * @return
     */
    public int hammingWeight(int n) {
        return 0;
    }


    /**
     * 14.数值的整数次方
     *
     * @param x
     * @param n
     * @return
     */
    public double myPow(double x, int n) {
        return 0.0;

    }


    /**
     * 15.打印从1到最大的n位数
     *
     * @param n
     * @return
     */
    public int[] printNumbers(int n) {
        return null;

    }


    /**
     * 16.删除链表的节点
     *
     * @param head
     * @param val
     * @return
     */
    public ListNode deleteNode(ListNode head, int val) {
        return null;

    }

    /**
     * 17.正则表达式的匹配
     *
     * @param s
     * @param p
     * @return
     */
    public boolean isMatch(String s, String p) {
        return false;

    }


    /**
     * 18.表示数值的字符串
     *
     * @param s
     * @return
     */
    public boolean isNumber(String s) {
        return false;

    }


    /**
     * 19.调整数组顺序使奇数位于偶数前面
     *
     * @param nums
     * @return
     */
    public int[] exchange(int[] nums) {
        return null;
    }


    /**
     * 20.链表中的倒数第k个节点
     *
     * @param head
     * @param k
     * @return
     */
    public ListNode getKthFromEnd(ListNode head, int k) {
        return null;
    }

    /**
     * 21.反转链表
     *
     * @param head
     * @return
     */
    public ListNode reverseList(ListNode head) {
        return null;

    }

    /**
     * 22.合并两个排序链表
     *
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        return null;
    }


    /**
     * 23.树的子结构
     *
     * @param A
     * @param B
     * @return
     */
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        return false;

    }


    /**
     * 24.二叉树的镜像
     *
     * @param root
     * @return
     */
    public TreeNode mirrorTree(TreeNode root) {
        return null;
    }


    /**
     * 25.对称的二叉树
     *
     * @param root
     * @return
     */
    public boolean isSymmetric(TreeNode root) {
        return false;
    }


    /**
     * 26.顺时针打印矩阵
     *
     * @param matrix
     * @return
     */
    public int[] spiralOrder(int[][] matrix) {
        return null;
    }

    /**
     * 27.包含min函数的栈
     */
    static class MinStack {

        /**
         * initialize your data structure here.
         */
        public MinStack() {

        }

        public void push(int x) {

        }

        public void pop() {

        }

        public int top() {
            return 0;
        }

        public int min() {
            return 0;

        }
    }


    /**
     * 28.栈的压入、弹出序列
     *
     * @param pushed
     * @param popped
     * @return
     */
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        return false;
    }


    /**
     * 29.从上到下打印二叉树
     *
     * @param root
     * @return
     */
    public int[] levelOrder(TreeNode root) {
        return null;
    }


    /**
     * 30. 从上到下打印二叉树II
     *
     * @param root
     * @return
     */
    public List<List<Integer>> levelOrder2(TreeNode root) {
        return null;
    }


    /**
     * 31. 从上到下打印二叉树III
     *
     * @param root
     * @return
     */
    public List<List<Integer>> levelOrder3(TreeNode root) {
        return null;
    }


    /**
     * 32.二叉搜索树的后序遍历序列
     *
     * @param postorder
     * @return
     */
    public boolean verifyPostorder(int[] postorder) {
        return false;

    }

    /**
     * 33.二叉树中和为某一值的路径
     *
     * @param root
     * @param target
     * @return
     */
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        return null;
    }


    /**
     * 34.复杂链表的复制
     *
     * @param head
     * @return
     */
    public Node copyRandomList(Node head) {
        return null;
    }


    /**
     * 35.二叉搜索树与双向链表
     *
     * @param root
     * @return
     */
    public Node treeToDoublyList(Node root) {
        return null;
    }


    /**
     * 36.序列化二叉树
     */
    static class Codec {

        // Encodes a tree to a single string.
        public String serialize(TreeNode root) {
            return null;
        }

        // Decodes your encoded data to tree.
        public TreeNode deserialize(String data) {
            return null;
        }
    }


    /**
     * 37.字符串的排列
     *
     * @param s
     * @return
     */
    public String[] permutation(String s) {
        return null;
    }


    /**
     * 38.数组中出现次数超过一半的数字
     *
     * @param nums
     * @return
     */
    public int majorityElement(int[] nums) {
        return 0;
    }


    /**
     * 39.最小的k个数
     *
     * @param arr
     * @param k
     * @return
     */
    public int[] getLeastNumbers(int[] arr, int k) {
        return null;
    }


    /**
     * 40.数据流中的中位数
     */
    static class MedianFinder {

        /**
         * initialize your data structure here.
         */
        public MedianFinder() {

        }

        public void addNum(int num) {

        }

        public double findMedian() {
            return 0.0;
        }
    }


    /**
     * 41.连续子数组的最大和
     *
     * @param nums
     * @return
     */
    public int maxSubArray(int[] nums) {
        return 0;
    }


    /**
     * 42.1-n整数中1出现的次数
     *
     * @param n
     * @return
     */
    public int countDigitOne(int n) {
        return 0;
    }


    /**
     * 43.数字序列中某一位的数字
     *
     * @param n
     * @return
     */
    public int findNthDigit(int n) {
        return 0;

    }


    /**
     * 44.把数组排成最小的数
     *
     * @param nums
     * @return
     */
    public String minNumber(int[] nums) {
        return null;

    }

    /**
     * 45.把数字翻译成字符串
     *
     * @param num
     * @return
     */
    public int translateNum(int num) {
        return 0;
    }


    /**
     * 46.礼物的最大值
     *
     * @param grid
     * @return
     */
    public int maxValue(int[][] grid) {
        return 0;

    }

    /**
     * 47.最长不含重复字符的子字符串
     *
     * @param s
     * @return
     */
    public int lengthOfLongestSubstring(String s) {
        return 0;
    }


    /**
     * 48.丑数
     *
     * @param n
     * @return
     */
    public int nthUglyNumber(int n) {
        return 0;
    }

    /**
     * 49.第一次只出现一次的字符
     *
     * @param s
     * @return
     */
    public char firstUniqChar(String s) {
        return ' ';

    }

    /**
     * 50.数组中的逆序对
     *
     * @param nums
     * @return
     */
    public int reversePairs(int[] nums) {
        return 0;
    }


    /**
     * 51.两个链表的第一个公共节点
     *
     * @param headA
     * @param headB
     * @return
     */
    ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        return null;
    }


    /**
     * 52.在排序数组中查找数字I
     *
     * @param nums
     * @param target
     * @return
     */
    public int search(int[] nums, int target) {
        return 0;
    }


    /**
     * 53.0-n-1中缺失的数字
     *
     * @param nums
     * @return
     */
    public int missingNumber(int[] nums) {
        return 0;
    }

    /**
     * 54.二叉搜索树中第k大节点
     *
     * @param root
     * @param k
     * @return
     */
    public int kthLargest(TreeNode root, int k) {
        return 0;
    }

    /**
     * 55.二叉树的深度
     *
     * @param root
     * @return
     */
    public int maxDepth(TreeNode root) {
        return 0;
    }

    /**
     * 56.平衡二叉树
     *
     * @param root
     * @return
     */
    public boolean isBalanced(TreeNode root) {
        return false;
    }

    /**
     * 57.数组中数字出现的次数
     *
     * @param nums
     * @return
     */
    public int[] singleNumbers(int[] nums) {
        return null;
    }


    /**
     * 58.数组中数字出现的次数II
     *
     * @param nums
     * @return
     */
    public int singleNumbers2(int[] nums) {
        return 0;
    }

    /**
     * 59.和为s的两个数字
     *
     * @param nums
     * @param target
     * @return
     */
    public int[] twoSum(int[] nums, int target) {
        return null;

    }

    /**
     * 60.和为s的连续正数序列
     *
     * @param target
     * @return
     */
    public int[][] findContinuousSequence(int target) {
        return null;
    }


    /**
     * 61.翻转单词顺序
     *
     * @param s
     * @return
     */
    public String reverseWords(String s) {
        return null;
    }

    /**
     * 62.左旋转字符串
     *
     * @param s
     * @param n
     * @return
     */
    public String reverseLeftWords(String s, int n) {
        return null;
    }

    /**
     * 63.滑动窗口的最大值
     *
     * @param nums
     * @param k
     * @return
     */
    public int[] maxSlidingWindow(int[] nums, int k) {
        return null;
    }


    /**
     * 64.n个骰子的点数
     *
     * @param n
     * @return
     */
    public double[] dicesProbability(int n) {
        return null;
    }


    /**
     * 65.扑克牌中的顺子
     *
     * @param nums
     * @return
     */
    public boolean isStraight(int[] nums) {
        return false;
    }


    /**
     * 66.圆圈中最后剩下的数字
     *
     * @param n
     * @param m
     * @return
     */
    public int lastRemaining(int n, int m) {
        return 0;
    }


    /**
     * 67.股票的最大利润
     *
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices) {
        return 0;
    }

    /**
     * 68.求1+2+...+n
     *
     * @param n
     * @return
     */
    public int sumNums(int n) {
        return 0;
    }


    /**
     * 69.不用加减乘除做加法
     *
     * @param a
     * @param b
     * @return
     */
    public int add(int a, int b) {
        return 0;
    }


    /**
     * 70.构造乘积数组
     *
     * @param a
     * @return
     */
    public int[] constructArr(int[] a) {
        return null;
    }

    /**
     * 71.把字符串转换成整数
     *
     * @param str
     * @return
     */
    public int strToInt(String str) {
        return 0;
    }


    /**
     * 72.二叉搜索树的最近公共祖先
     *
     * @param root
     * @param p
     * @param q
     * @return
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return null;
    }


    /**
     * 73.二叉搜索树的最近公共祖先II
     *
     * @param root
     * @param p
     * @param q
     * @return
     */
    public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {
        return null;
    }

    /**
     * 74.整数除法
     * 75.二进制加法
     * 76.前n个数字二进制中1的个数
     * 77.只出现一次的数字
     * 78.单词长度的最大乘积
     * 79.排序数组中两个数字之和
     * 80.数组中和为0的三个数
     * 81.和大于等于target的最短子数组
     * 82.乘积小于k的子数组
     * 83.和为k的子数组
     * 84.0和1个数相同的子数组
     * 85.左右两边子数组的和相等
     * 86.二维子矩阵的和
     * 87.字符串中的变位词
     * 88.字符串中的所有变位词
     * 89.不含重复字符的最长子字符串
     * 90.含有所有字符的最短字符串
     * 91.有效的回文
     * 92.最多删除一个字符得到回文
     * 93.回文字符串的个数
     * 94.删除链表的倒数第n个节点
     * 95.链表中环的入口节点
     * 96.两个链表的第一个重合节点
     */

}





